---
title: "rnaseq"
output: html_document
---

```{R}
# ============================
# DEG: MDD vs Control (GEO)
# ============================

# Pacotes ----
suppressPackageStartupMessages({
  library(tidyverse)
  library(data.table)
  library(DESeq2)
  library(GEOquery)
})

# Pastas ----
DATA_DIR <- "."
OUT_DIR  <- "deg_outputs"
dir.create(OUT_DIR, showWarnings = FALSE, recursive = TRUE)

# Utils ----
read_any <- function(path) {
  # Lê .csv(.gz) ou .txt(.gz); infere separador
  ext <- tools::file_ext(path)
  if (grepl("csv", ext, ignore.case = TRUE)) {
    dt <- data.table::fread(path, sep = ",", header = TRUE, data.table = FALSE)
  } else {
    # tenta tab; se falhar, vírgula
    dt <- tryCatch(
      data.table::fread(path, sep = "\t", header = TRUE, data.table = FALSE),
      error = function(e) data.table::fread(path, sep = ",", header = TRUE, data.table = FALSE)
    )
  }
  as.data.frame(dt)
}

make_counts_matrix <- function(df, gene_col = NULL) {
  # If user tells us which column holds gene IDs, use it
  if (!is.null(gene_col) && gene_col %in% colnames(df)) {
    rn <- as.character(df[[gene_col]])
    df <- df[, setdiff(colnames(df), gene_col), drop = FALSE]
    rownames(df) <- rn
  } else {
    # Fallback: common ID column names
    id_names <- c("gene_id","Geneid","GeneID","Gene","EntrezID","Gene.Symbol","GeneSymbol")
    if (colnames(df)[1] %in% id_names) {
      rn <- as.character(df[[1]])
      df <- df[, -1, drop = FALSE]
      rownames(df) <- rn
    }
  }

  # Convert remaining columns to numeric safely
  numdf <- suppressWarnings(
    as.data.frame(lapply(df, function(x) as.numeric(as.character(x))), check.names = FALSE)
  )
  rownames(numdf) <- rownames(df)
  numdf[is.na(numdf)] <- 0
  as.matrix(numdf)
}

save_results <- function(dds, res, tag) {
  # Resultados
  res_df <- as.data.frame(res) %>%
    rownames_to_column("gene") %>%
    arrange(padj, pvalue)
  write.csv(res_df, file = file.path(OUT_DIR, paste0(tag, "_DESeq2_results.csv")), row.names = FALSE)
  
  # MA plot
  png(file.path(OUT_DIR, paste0(tag, "_MAplot.png")), width = 1200, height = 900, res = 150)
  DESeq2::plotMA(res, main = paste(tag, "MA plot"), ylim = c(-4,4))
  dev.off()
  
  # Volcano
  vol <- res_df %>%
    mutate(sig = !is.na(padj) & padj < 0.05) %>%
    ggplot(aes(x = log2FoldChange, y = -log10(pvalue))) +
    geom_point(aes(alpha = sig)) +
    scale_alpha_manual(values = c("TRUE" = 0.9, "FALSE" = 0.3)) +
    labs(title = paste(tag, "Volcano"), x = "log2FC (MDD vs Control)", y = "-log10(p)") +
    theme_minimal()
  ggsave(filename = file.path(OUT_DIR, paste0(tag, "_Volcano.png")), plot = vol, width = 7, height = 6, dpi = 150)
}

# ---- Add once to your script ----
find_degs <- function(counts, meta, sample_col, condition_col, mdd_values, control_values, tag) {
  stopifnot(sample_col %in% colnames(meta))
  meta[[sample_col]] <- make.names(as.character(meta[[sample_col]]))
  colnames(counts)   <- make.names(colnames(counts))
  common <- intersect(colnames(counts), meta[[sample_col]])
  
  if (length(common) < 4) stop(paste("Poucas amostras em comum para", tag))
  
  counts <- counts[, common, drop = FALSE]
  meta   <- meta[match(common, meta[[sample_col]]), , drop = FALSE]

  cond_raw <- as.character(meta[[condition_col]])
  cond     <- ifelse(cond_raw %in% mdd_values, "MDD",
              ifelse(cond_raw %in% control_values, "Control", NA))
  keep_s   <- !is.na(cond)
  counts   <- counts[, keep_s, drop = FALSE]
  cond     <- cond[keep_s]
  meta     <- meta[keep_s, , drop = FALSE]
  meta$condition <- factor(cond, levels = c("Control","MDD"))

  # quick gene filter
  keep_g <- rowSums(counts >= 10) >= max(2, floor(0.1*ncol(counts)))
  counts <- counts[keep_g, , drop = FALSE]

  non_integer <- any(abs(counts - round(counts)) > 1e-8)

  if (!non_integer) {
    # ---- DESeq2 path ----
    suppressPackageStartupMessages(library(DESeq2))
    dds <- DESeqDataSetFromMatrix(countData = round(counts),
                                  colData   = data.frame(condition=meta$condition,row.names=colnames(counts)),
                                  design    = ~ condition)
    dds <- DESeq(dds)
    res <- results(dds, contrast = c("condition","MDD","Control"))
    # save
    res_df <- as.data.frame(res) %>% tibble::rownames_to_column("gene") %>% dplyr::arrange(padj, pvalue)
    dir.create("deg_outputs", showWarnings = FALSE)
    write.csv(res_df, file = file.path("deg_outputs", paste0(tag,"_deseq_degs.csv")), row.names = FALSE)

    return(list(method="DESeq2", res=res_df))
  } else {
    # ---- limma-voom path (for non-integers) ----
    suppressPackageStartupMessages({
      library(edgeR); library(limma); library(ggplot2)
    })
    y <- DGEList(counts=counts)
    # TMM normalization still OK on non-integer library sizes
    y <- calcNormFactors(y, method="TMM")
    design <- model.matrix(~ meta$condition)
    colnames(design) <- c("Intercept","MDD_vs_Control")
    v <- voom(y, design, plot=FALSE)
    fit <- lmFit(v, design)
    fit <- eBayes(fit, trend=TRUE, robust=TRUE)
    tt  <- topTable(fit, coef="MDD_vs_Control", number=Inf, sort.by="P")
    tt  <- tt %>% tibble::rownames_to_column("gene") %>%
      dplyr::rename(log2FoldChange = logFC, pvalue = P.Value, padj = adj.P.Val, baseMean = AveExpr)

    dir.create("deg_outputs", showWarnings = FALSE)
    write.csv(tt, file = file.path("deg_outputs", paste0(tag,"_voom_degs.csv")), row.names = FALSE)

    return(list(method="voom", res=tt))
  }
}
```


```{R}
# ============================
# GSE101521 (DLPFC BA9)
# Arquivo: GSE101521_totalRNA_counts.csv.gz
# Grupos: CON vs MDD (inclui MDD non-suicide e MDD suicides)
# ============================
message("Processando GSE101521 ...")

# Mudar make counts
cnt_101521 <- read_any(file.path(DATA_DIR, "GSE101521_totalRNA_counts.csv.gz")) %>%
  make_counts_matrix("V1")

# Metadata via GEOquery
gse_101521 <- getGEO("GSE101521", GSEMatrix = TRUE)
pheno_101521 <- Biobase::pData(gse_101521[[2]]) 

pheno_101521_ns <- pheno_101521 %>%
  mutate(group = case_when(
    grepl("\\bCON\\b|control", characteristics_ch1, ignore.case = TRUE) ~ "Control",
    grepl("(MDD)", characteristics_ch1, ignore.case = TRUE) ~ "MDD",
    TRUE ~ NA_character_
  ))

pheno_101521_s <- pheno_101521 %>%
  mutate(group = case_when(
    grepl("\\bCON\\b|control", characteristics_ch1, ignore.case = TRUE) ~ "Control",
    grepl("(MDD-S)", characteristics_ch1, ignore.case = TRUE) ~ "MDD-S",
    grepl("(MDD)", characteristics_ch1, ignore.case = TRUE) ~ "MDD-NS",
    TRUE ~ NA_character_
  ))

pheno_101521_s <- pheno_101521_s %>%
  dplyr::filter(title %in% colnames(cnt_101521))
pheno_101521_ns <- pheno_101521_ns %>%
  dplyr::filter(title %in% colnames(cnt_101521))

cat(length(pheno_101521_ns$title) == ncol(cnt_101521))
cat(length(pheno_101521_s$title) == ncol(cnt_101521))

res_101521_s <- find_degs(
  counts        = cnt_101521,
  meta          = pheno_101521_s %>% select(sample_id = title, condition = group),
  sample_col    = "sample_id",
  condition_col = "condition",
  mdd_values    = c("MDD-S"),
  control_values= c("Control"),
  tag           = "101521_s"
)

res_101521_ns <- find_degs(
  counts        = cnt_101521,
  meta          = pheno_101521_ns %>% select(sample_id = title, condition = group),
  sample_col    = "sample_id",
  condition_col = "condition",
  mdd_values    = c("MDD"),
  control_values= c("Control"),
  tag           = "101521_ns"
)

# ============================
# GSE80655 (clinically annotated brain RNA-seq)
# Arquivo: GSE80655_GeneExpressionData_Updated_3-26-2018.txt.gz
# ============================
message("Processando GSE80655 ...")
cnt_80655 <- read_any(file.path(DATA_DIR, "GSE80655_GeneExpressionData_Updated_3-26-2018.txt.gz")) %>%
  make_counts_matrix("gene_id")

gse_80655 <- getGEO("GSE80655", GSEMatrix = TRUE)
pheno_80655 <- Biobase::pData(gse_80655[[1]]) 

cat(length(pheno_80655$description) == ncol(cnt_80655))

# Phenotypes
pheno_80655 <- pheno_80655[, !duplicated(colnames(pheno_80655))]%>%
  mutate(
    group = case_when(
      grepl("\\bControl\\b|non-psy|healthy", `characteristics_ch1.3`, ignore.case = TRUE) ~ "Control",
      grepl("\\bMajor Depression\\b|major\\s*depress", `characteristics_ch1.3`, ignore.case = TRUE) ~ "MDD",
      grepl("\\bSchizophrenia", `characteristics_ch1.3`, ignore.case = TRUE) ~ "SCZ",
      grepl("\\Bipolar Disorder", `characteristics_ch1.3`, ignore.case = TRUE) ~ "BPD",
      TRUE ~ NA_character_
    )
  )

res_80655 <- find_degs(
  counts        = cnt_80655,
  meta          = pheno_80655 %>% select(sample_id = description, condition = group),
  sample_col    = "sample_id",
  condition_col = "condition",
  mdd_values    = c("MDD"),
  control_values= c("Control"),
  tag           = "80655"
)


# ============================
# GSE214921 (OFC bulk RNA-seq, MDD vs Control)
# Arquivo: GSE214921_human_MDD_filtered_featurecounts_geo.txt.gz
# ============================
message("Processando GSE214921 ...")
cnt_214921 <- read_any(file.path(DATA_DIR, "GSE214921_human_MDD_filtered_featurecounts_geo.txt.gz")) %>%
  make_counts_matrix("gene_id")

gse_214921 <- getGEO("GSE214921", GSEMatrix = TRUE)

# Phenotypes
pheno_214921 <- Biobase::pData(gse_214921[[1]]) %>%
  mutate(group = case_when(
    grepl("MDD", `condition:ch1`, ignore.case = TRUE) ~ "MDD",
    grepl("control", `condition:ch1`, ignore.case = TRUE) ~ "Control",
    TRUE ~ NA_character_
  ))

cat(length(pheno_214921$title) == ncol(cnt_214921))

res_214921 <- find_degs(
  counts        = cnt_214921, 
  meta          = pheno_214921 %>% select(sample_id = title, condition = group),
  sample_col    = "sample_id",
  condition_col = "condition",
  mdd_values    = c("MDD"),
  control_values= c("Control"),
  tag           = "214921"
)

# ============================
# GSE248260 (white matter BA47: suicide vs control)
# Arquivo: GSE248260_white_matter_count_matrix.csv.gz
# ATENÇÃO: este estudo é suicídio vs não-suicídio (nem sempre MDD). Rodamos separado.
# ============================
message("Processando GSE248260 ...")
cnt_248260 <- read_any(file.path(DATA_DIR, "GSE248260_white_matter_count_matrix.csv.gz")) %>% make_counts_matrix()

gse_248260 <- getGEO("GSE248260", GSEMatrix = TRUE)
pheno_248260 <- Biobase::pData(gse_248260[[1]]) %>%
  as_tibble(rownames = "geo_accession") %>%
  extract_group()

# Phenotypes
pheno_248260 <- pheno_248260 %>%
  mutate(group_simple = case_when(
    grepl("suic", group_inferred, ignore.case = TRUE) ~ "Suicide",
    grepl("control|non-psy|accidental", group_inferred, ignore.case = TRUE) ~ "Control",
    TRUE ~ NA_character_
  ))

res_248260 <- prep_and_run_deseq(
  counts        = cnt_248260,
  meta          = pheno_248260 %>% select(sample_id = geo_accession, condition = group_simple),
  sample_col    = "sample_id",
  condition_col = "condition",
  mdd_values    = c("Suicide"),   # por padrão, aqui não é MDD; é suicídio
  control_values= c("Control"),
  tag           = "GSE248260_Suicide_vs_Control"
)

message("Concluído. Resultados em: ", normalizePath(OUT_DIR))

```
```{R}
# filtra por p e log
library(readr)
setwd("/home/gbiuser/Documents/vitoria/usp-masters")
res_101521_s <- read_csv("deg_outputs/101521_s_voom_degs.csv")
res_101521_ns <- read_csv("deg_outputs/101521_ns_voom_degs.csv")

res_80655 <- read_csv("deg_outputs/80655_deseq_degs.csv")
res_214921 <- read_csv("deg_outputs/214921_deseq_degs.csv")

padj_thr <- 0.1
logfc_thr <- 0.5

res_101521_ns_filtered <- res_101521_ns %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

res_101521_s_filtered <- res_101521_s %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

res_80655_filtered <- res_80655 %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

res_214951_filtered <- res_214921 %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

degs_80655 <- res_80655_filtered$gene
degs_214951 <- res_214951_filtered$gene
```


```{r message=FALSE, warning=FALSE}
normalize_ids <- function(x) {
  x <- trimws(x)
  x <- toupper(x)
  sub("\\.\\d+$", "", x)  # drop .1, .2, ...
}
# MAPPINMG

library(biomaRt)
biomart_mapping <- function(values, 
                            filters_to_try = NULL,
                            mart = NULL,
                            to_attribute = "hgnc_symbol",
                            verbose = FALSE) {
  # Conecta ao Ensembl se não for passado
  if (is.null(mart)) {
    mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
  }

  # Filtros padrão se não forem especificados
  if (is.null(filters_to_try)) {
    filters_to_try <- c(
      "ensembl_gene_id", 
      "ensembl_transcript_id",
      "ensembl_peptide_id",
      "hgnc_symbol", "chembl", "embl", "entrezgene_id",
      "external_gene_name", "hgnc_id", "hpa_id", "hpa_accession", "uniprot_gn_id"
    )
  } else{
    valid_filters <- listFilters(mart)$name
    filters_to_try <- intersect(filters_to_try, valid_filters)
  }

  # Lista para guardar os resultados como data frames
  all_results <- list()

  for (filtro in filters_to_try) {
    if (verbose) cat("Tentando filtro:", filtro, "\n")

    res <- tryCatch({
      getBM(
        attributes = c(filtro, to_attribute, "external_gene_name"),
        filters = filtro,
        values = values,
        mart = mart
      )
    }, error = function(e) {
      if (verbose) message("Erro com filtro: ", filtro, " - ", e$message)
      NULL
    })

    if (!is.null(res) && nrow(res) > 0) {
      # Fallback: if HGNC is empty, use external_gene_name
      res$hgnc_symbol[res$hgnc_symbol == "" | is.na(res$hgnc_symbol)] <- 
        res$external_gene_name[res$hgnc_symbol == "" | is.na(res$hgnc_symbol)]
    
      df <- res[, c(filtro, "hgnc_symbol")]
      colnames(df) <- c("Query", "HGNC_ID")
      all_results[[filtro]] <- df
    }
  }

  # Combina tudo em um único data frame
  if (length(all_results) == 0) {
    return(data.frame(Query = character(0), HGNC_ID = character(0)))
  }

  final_df <- do.call(rbind, all_results)
  return(final_df)
}

#######################################################################
library(data.table)

hgnc_dataset_mapping <- function(targets) {
  library(data.table)

  # Baixar dataset HGNC
  hgnc_url <- "https://storage.googleapis.com/public-download-files/hgnc/tsv/tsv/hgnc_complete_set.txt"
  hgnc_file <- tempfile(fileext = ".tsv")
  download.file(hgnc_url, hgnc_file, quiet = TRUE)

  # Ler com segurança
  hgnc <- fread(hgnc_file, sep = "\t", quote = "", fill = TRUE)

  # Garantir colunas necessárias
  cols <- c("symbol", "alias_symbol", "prev_symbol", "name", "ensembl_gene_id")
  for (col in cols) if (!col %in% names(hgnc)) hgnc[[col]] <- NA_character_

  # Função de expansão
  expand_aliases <- function(symbols, main_symbol) {
    if (is.na(symbols) || symbols == "") return(NULL)
    expanded <- unlist(strsplit(symbols, "\\|"))
    if (length(expanded) == 0) return(NULL)
    data.table(input = toupper(trimws(expanded)), hgnc_symbol = main_symbol)
  }

  safe_rbind <- function(lst) {
    lst <- lst[!sapply(lst, is.null)]
    if (length(lst) == 0) return(data.table(input = character(), hgnc_symbol = character()))
    rbindlist(lst, fill = TRUE)
  }

  # Expandir
  alias_dt  <- safe_rbind(mapply(expand_aliases, hgnc$alias_symbol, hgnc$symbol, SIMPLIFY = FALSE))
  prev_dt   <- safe_rbind(mapply(expand_aliases, hgnc$prev_symbol, hgnc$symbol, SIMPLIFY = FALSE))
  symbol_dt <- data.table(input = toupper(hgnc$symbol), hgnc_symbol = hgnc$symbol)
  name_dt   <- data.table(input = toupper(hgnc$name), hgnc_symbol = hgnc$symbol)

  expanded <- rbindlist(list(symbol_dt, alias_dt, prev_dt, name_dt), fill = TRUE, use.names = TRUE)
  expanded <- unique(expanded[!is.na(input)])

  # Mapeamento
  targets_clean <- toupper(trimws(targets))
  mapped <- expanded[input %in% targets_clean]

  if (nrow(mapped) == 0) {
    warning("Nenhum mapeamento encontrado para os targets fornecidos.")
    return(data.frame(Query = targets, HGNC_ID = NA_character_))
  }

  result <- unique(data.table(Query = mapped$input, HGNC_ID = mapped$hgnc_symbol))
  return(as.data.frame(result))
}

#######################################################################
  
library(hgnc)
library(lubridate)
library(data.table)

hgnc_mapping <- function(values, 
                         from_cols = NULL, 
                         to = "symbol", 
                         hgnc_dataset = NULL, 
                         verbose = FALSE) {
  if (is.null(hgnc_dataset)) {
    if (verbose) cat("Importando base HGNC...\n")
    hgnc_dataset <- import_hgnc_dataset()
  }

  if (is.null(from_cols)) {
    from_cols <- c("hgnc_id", "symbol", "name", "entrez_id", "ensembl_gene_id", "uniprot_ids")
  }
  
  hgnc_long <- setDT(hgnc_dataset)[
    , .(uniprot_id = unlist(strsplit(as.character(uniprot_ids), ",\\s*"))),  # force to character
    by = .(hgnc_id, symbol)
  ]


  # Safe wrapper
  safe_crosswalk <- function(value, from, to, hgnc_dataset) {
    tryCatch({
      crosswalk(value = value, from = from, to = to, hgnc_dataset = hgnc_dataset)
    }, error = function(e) {
      if (verbose) message("Erro na coluna ", from, ": ", e$message)
      NULL
    })
  }

  # Lista para guardar resultados (query, id)
  results_list <- list()

  for (col in from_cols) {
    if (verbose) cat("Tentando coluna:", col, "\n")
    
    if (col == "uniprot_ids") {
      matched <- hgnc_long[uniprot_id %in% values, .(Query = uniprot_id, HGNC_ID = symbol)]
      if (nrow(matched) > 0) results_list[[length(results_list) + 1]] <- matched
    } else {
      for (val in values) {
        res <- tryCatch({
          crosswalk(value = val, from = col, to = to, hgnc_dataset = hgnc_dataset)
        }, error = function(e) {
          if (verbose) message("Erro na coluna ", col, ": ", e$message)
          NULL
        })
        if (!is.null(res) && length(res) > 0) {
          results_list[[length(results_list) + 1]] <- data.frame(Query = val, HGNC_ID = res)
        }
      }
    }
  }

  # Combina tudo e remove duplicatas
  if (length(results_list) == 0) {
    return(data.frame(Query = character(0), HGNC_ID = character(0)))
  }

  final_df <- unique(do.call(rbind, results_list))
  return(final_df)
}

#######################################################################
library(mygene)

mygene_mapping <- function(targets, filters=NULL) {
  
  if(is.null(filters)){
    filters <- "ensembl.gene,emsembl,ensemblgene,uniprot,entrezgene,symbol,name,hgnc,refseq,alias"
  }
  
  res <- suppressWarnings(
    queryMany(targets, scopes = filters,
              fields = "symbol", species = "human", 
              return.as = "records")
  )
  
  if (is.null(res) || length(res) == 0) {
    return(data.frame(Query = character(0), HGNC_ID = character(0), 
                     stringsAsFactors = FALSE))
  }
  
  # Helper for NULL coalescing
  `%||%` <- function(x, y) if (is.null(x)) y else x
  
  # Process the records format
  queries <- sapply(res, function(x) x$query %||% NA)
  symbols <- sapply(res, function(x) x$symbol %||% NA)
  
  df <- data.frame(
    Query = queries,
    HGNC_ID = symbols,
    stringsAsFactors = FALSE
  )
  
  # Remove rows without valid HGNC mapping (including notfound entries)
  df <- df[!is.na(df$HGNC_ID) & df$HGNC_ID != "" & !is.na(df$Query), , drop = FALSE]
  rownames(df) <- NULL
  
  return(df)
}

#######################################################################

map_hgnc_all_methods <- function(targets, verbose = TRUE) {
  
  targets <- normalize_ids(targets)
  
  # Run each mapping function with proper error handling
  results <- list()

  # Biomart
  if (verbose) cat("Running biomart_mapping...\n")
  res_biomart <- tryCatch({
    df <- biomart_mapping(targets)
    df$Source <- "biomart"
    df
  }, error = function(e) {
    warning("biomart_mapping failed: ", e$message)
    NULL
  })
  if (!is.null(res_biomart)) results[["biomart"]] <- res_biomart

  # HGNC downloaded dataset
  if (verbose) cat("\nRunning hgnc_dataset_mapping...\n")
  res_dataset <- tryCatch({
    df <- hgnc_dataset_mapping(targets)
    df$Source <- "hgnc_dataset"
    df
  }, error = function(e) {
    warning("hgnc_dataset_mapping failed: ", e$message)
    NULL
  })
  if (!is.null(res_dataset)) results[["hgnc_dataset"]] <- res_dataset

  # hgnc package
  if (verbose) cat("\nRunning hgnc_package\n")
  res_hgnc <- tryCatch({
    df <- hgnc_mapping(targets, verbose)
    df$Source <- "hgnc_package"
    df
  }, error = function(e) {
    warning("hgnc_package failed: ", e$message)
    NULL
  })
  if (!is.null(res_hgnc)) results[["hgnc_package"]] <- res_hgnc

  # mygene
  if (verbose) cat("\nRunning mygene_mapping...\n")
  res_mygene <- tryCatch({
    df <- mygene_mapping(targets)
    
    # Only add Source if df is not empty
    if (nrow(df) > 0) {
      # Remove rownames before adding column
      rownames(df) <- NULL
      df$Source <- "mygene"
      df
    } else {
      message("No HGNC IDs found for these targets")
      NULL
    }
  }, error = function(e) {
    warning("mygene_mapping failed: ", e$message)
    NULL
  })
  if (!is.null(res_mygene)) results[["mygene"]] <- res_mygene

  if (verbose) cat("\nCombining results...\n")
  
  # Combine all results
  if (length(results) == 0) {
    return(data.frame(Query = character(0), HGNC_ID = character(0), Source = character(0)))
  }

  combined <- do.call(rbind, results)
  return(combined)
}
```

```{R}
mappings_80655 <- map_hgnc_all_methods(degs_80655)
all_80655 <- unique(mappings_80655$HGNC_ID)
all_80655 <- all_80655[!is.na(all_80655)]

mappings_214951 <- map_hgnc_all_methods(degs_214951)
all_214951 <- unique(mappings_214951$HGNC_ID)
all_214951 <- all_214951[!is.na(all_214951)]

all<-c(all_214951,all_80655)
```


```{r message=FALSE, warning=FALSE, include=FALSE}
# Pasta com os CSVs das interseções
csv_folder <- "data/target_prediction/intersections"

# Lista fixa para intersectar
# snrnaseq_intersection <- as.character(snrnaseq_intersection)  # garantir vetor de caracteres

# Lista para guardar os resultados
intersection_results <- list()

# Ler cada arquivo CSV e fazer interseção com snrnaseq_intersection
csv_files <- list.files(csv_folder, pattern = "\\.csv$", full.names = TRUE)

for (file in csv_files) {
  # Read raw lines first
  raw_lines <- readLines(file, warn = FALSE)

  # Skip if all lines are either empty or just '""'
  if (all(trimws(raw_lines) %in% c("", "\"\""))) {
    message(paste("Skipping file with only '\"\"' or blank lines:", file))
    next
  }
  
  # Nome base do arquivo para usar como key
  key <- gsub("^intersection_|\\.csv$", "", basename(file))
  
  # Ler CSV
  # print(file)
  df <- read.csv(file, stringsAsFactors = FALSE)
  # print(file)
  # Garantir vetor
  vec <- as.character(df$target)
  
  # Interseção com snrnaseq_intersection
  inter <- intersect(vec, all)
  
  # Salvar na lista
  intersection_results[[key]] <- inter
}
```

