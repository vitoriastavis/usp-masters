---
title: "rnaseq"
output: html_document
---

```{R}
# ============================
# DEG: MDD vs Control (GEO)
# ============================

# Pacotes ----
suppressPackageStartupMessages({
  library(readr)
  library(dplyr)
  library(tidyverse)
  library(data.table)
  library(DESeq2)
  library(GEOquery)
  library(edgeR)
})

# Pastas ----
DATA_DIR <- "."
OUT_DIR  <- "deg_outputs"
dir.create(OUT_DIR, showWarnings = FALSE, recursive = TRUE)
```
```{R}
# Utils ----
read_any <- function(path) {
  # Lê .csv(.gz) ou .txt(.gz); infere separador
  ext <- tools::file_ext(path)
  if (grepl("csv", ext, ignore.case = TRUE)) {
    dt <- data.table::fread(path, sep = ",", header = TRUE, data.table = FALSE)
  } else {
    # tenta tab; se falhar, vírgula
    dt <- tryCatch(
      data.table::fread(path, sep = "\t", header = TRUE, data.table = FALSE),
      error = function(e) data.table::fread(path, sep = ",", header = TRUE, data.table = FALSE)
    )
  }
  as.data.frame(dt)
}

make_counts_matrix <- function(df, gene_col = NULL) {
  # If user tells us which column holds gene IDs, use it
  if (!is.null(gene_col) && gene_col %in% colnames(df)) {
    rn <- as.character(df[[gene_col]])
    df <- df[, setdiff(colnames(df), gene_col), drop = FALSE]
    rownames(df) <- rn
  } else {
    # Fallback: common ID column names
    id_names <- c("gene_id","Geneid","GeneID","Gene","EntrezID","Gene.Symbol","GeneSymbol")
    if (colnames(df)[1] %in% id_names) {
      rn <- as.character(df[[1]])
      df <- df[, -1, drop = FALSE]
      rownames(df) <- rn
    }
  }

  # Convert remaining columns to numeric safely
  numdf <- suppressWarnings(
    as.data.frame(lapply(df, function(x) as.numeric(as.character(x))), check.names = FALSE)
  )
  rownames(numdf) <- rownames(df)
  numdf[is.na(numdf)] <- 0
  as.matrix(numdf)
}

save_results <- function(dds, res, tag) {
  # Resultados
  res_df <- as.data.frame(res) %>%
    rownames_to_column("gene") %>%
    arrange(padj, pvalue)
  write.csv(res_df, file = file.path(OUT_DIR, paste0(tag, "_DESeq2_results.csv")), row.names = FALSE)
  
  # MA plot
  png(file.path(OUT_DIR, paste0(tag, "_MAplot.png")), width = 1200, height = 900, res = 150)
  DESeq2::plotMA(res, main = paste(tag, "MA plot"), ylim = c(-4,4))
  dev.off()
  
  # Volcano
  vol <- res_df %>%
    mutate(sig = !is.na(padj) & padj < 0.05) %>%
    ggplot(aes(x = log2FoldChange, y = -log10(pvalue))) +
    geom_point(aes(alpha = sig)) +
    scale_alpha_manual(values = c("TRUE" = 0.9, "FALSE" = 0.3)) +
    labs(title = paste(tag, "Volcano"), x = "log2FC (MDD vs Control)", y = "-log10(p)") +
    theme_minimal()
  ggsave(filename = file.path(OUT_DIR, paste0(tag, "_Volcano.png")), plot = vol, width = 7, height = 6, dpi = 150)
}

find_degs <- function(counts, meta, sample_col, condition_col,
                      mdd_values, control_values, tag,
                      covariates = NULL) {
  stopifnot(sample_col %in% colnames(meta))
  meta[[sample_col]] <- make.names(as.character(meta[[sample_col]]))
  colnames(counts)   <- make.names(colnames(counts))
  common <- intersect(colnames(counts), meta[[sample_col]])
  
  if (length(common) < 4) stop(paste("Poucas amostras em comum para", tag))
  
  counts <- counts[, common, drop = FALSE]
  meta   <- meta[match(common, meta[[sample_col]]), , drop = FALSE]
  
  # Condição: MDD / Control
  cond_raw <- as.character(meta[[condition_col]])
  cond     <- ifelse(cond_raw %in% mdd_values, "MDD",
              ifelse(cond_raw %in% control_values, "Control", NA))
  keep_s   <- !is.na(cond)
  counts   <- counts[, keep_s, drop = FALSE]
  cond     <- cond[keep_s]
  meta     <- meta[keep_s, , drop = FALSE]
  meta$condition <- factor(cond, levels = c("Control","MDD"))
  
  # checar covariáveis
  if (!is.null(covariates)) {
    missing_cov <- setdiff(covariates, colnames(meta))
    if (length(missing_cov) > 0) {
      stop("Covariáveis não encontradas em meta: ",
           paste(missing_cov, collapse = ", "))
    }
  }
  
  # construir colData/data.frame para design
  if (is.null(covariates)) {
    colData <- data.frame(condition = meta$condition,
                          row.names = colnames(counts))
  } else {
    colData <- meta[, c("condition", covariates), drop = FALSE]
    rownames(colData) <- colnames(counts)
    colData$condition <- droplevels(colData$condition)
  }
  
  # REMOVER amostras com NA em qualquer covariável/condition
  na_samp <- apply(colData, 1, function(x) any(is.na(x)))
  if (any(na_samp)) {
    message("Removendo ", sum(na_samp),
            " amostras com NA em covariáveis para ", tag)
    colData <- colData[!na_samp, , drop = FALSE]
    counts  <- counts[, rownames(colData), drop = FALSE]
  }
  
  # filtro rápido de genes (já com amostras limpas)
  keep_g <- rowSums(counts >= 4) >= max(2, floor(0.1 * ncol(counts)))
  counts <- counts[keep_g, , drop = FALSE]
  
  non_integer <- any(abs(counts - round(counts)) > 1e-8)
  
  # fórmula do design: ~ cov1 + cov2 + ... + condition (sempre por último)
  design_terms   <- c(if (!is.null(covariates)) covariates, "condition")
  design_formula <- as.formula(paste("~", paste(design_terms, collapse = " + ")))
  
  if (!non_integer) {
    # ---- DESeq2 path ----
    suppressPackageStartupMessages(library(DESeq2))
    dds <- DESeqDataSetFromMatrix(
      countData = round(counts),
      colData   = colData,
      design    = design_formula
    )
    
    dds <- DESeq(dds)
    res <- results(dds, contrast = c("condition","MDD","Control"))
    
    res_df <- as.data.frame(res) %>%
      tibble::rownames_to_column("gene") %>%
      dplyr::arrange(padj, pvalue)
    
    dir.create("deg_outputs", showWarnings = FALSE)
    write.csv(res_df,
              file = file.path("deg_outputs", paste0(tag,"_deseq_degs.csv")),
              row.names = FALSE)
    
    return(list(method = "DESeq2", res = res_df))
    
  } else {
    # ---- limma-voom path ----
    suppressPackageStartupMessages({
      library(edgeR); library(limma); library(ggplot2)
    })
    
    y <- DGEList(counts = counts)
    y <- calcNormFactors(y, method = "TMM")
    
    design <- model.matrix(design_formula, data = colData)
    colnames(design)[ncol(design)] <- "MDD_vs_Control"  # último coef. é conditionMDD
    
    v   <- voom(y, design, plot = FALSE)
    fit <- lmFit(v, design)
    fit <- eBayes(fit, trend = TRUE, robust = TRUE)
    
    coef_name <- colnames(design)[ncol(design)]
    tt  <- topTable(fit, coef = coef_name, number = Inf, sort.by = "P")
    tt  <- tt %>%
      tibble::rownames_to_column("gene") %>%
      dplyr::rename(
        log2FoldChange = logFC,
        pvalue         = P.Value,
        padj           = adj.P.Val,
        baseMean       = AveExpr
      )
    
    dir.create("deg_outputs", showWarnings = FALSE)
    write.csv(tt,
              file = file.path("deg_outputs", paste0(tag,"_voom_degs.csv")),
              row.names = FALSE)
    
    return(list(method = "voom", res = tt))
  }
}


parse_geo_characteristics <- function(pheno) {
  ph <- pheno %>%
    as.data.frame() %>%
    tibble::rownames_to_column("sample_id")
  
  long <- ph %>%
    tidyr::pivot_longer(
      cols = dplyr::starts_with("characteristics_ch1"),
      names_to  = "char_col",
      values_to = "char"
    ) %>%
    dplyr::filter(!is.na(char), char != "") %>%
    tidyr::separate(
      col  = char,
      into = c("key", "value"),
      sep  = ":\\s*",
      extra = "merge",
      fill  = "right"
    ) %>%
    dplyr::mutate(
      key   = tolower(trimws(key)),
      value = trimws(value)
    ) %>%
    dplyr::mutate(
      std_key = dplyr::case_when(
        # age at death → age
        grepl("age at death", key) ~ "age",
        # age "simples", evitando coisas tipo 'age of onset'
        grepl("\\bage\\b", key) & !grepl("onset|first episode", key) ~ "age",
        # sex ou gender → sex
        grepl("sex|gender", key) ~ "sex",
        # postmortem interval / PMI
        grepl("post.?mortem|pmi", key) ~ "pmi",
        # brain pH (ex: "brain ph")
        grepl("brain\\s*pH", key, ignore.case = TRUE) ~ "brain_ph",
        grepl("brain\\s*ph", key) ~ "brain_ph",
        # RIN / RNA integrity
        grepl("rin|rna integrity", key) ~ "rin",
        TRUE ~ key
      )
    )

  wide_char <- long %>%
    dplyr::group_by(sample_id, std_key) %>%
    dplyr::summarise(value = value[1], .groups = "drop") %>%  # escolhe o primeiro valor
    tidyr::pivot_wider(
      names_from  = std_key,
      values_from = value
    )
  
  ph_final <- ph %>%
    dplyr::left_join(wide_char, by = "sample_id") %>%
    tibble::column_to_rownames("sample_id")
  
  # Pós-processamento
  # idade numérica (aceita "45", "45 years", etc.)
  if ("age" %in% colnames(ph_final)) {
    ph_final$age <- gsub("[^0-9.]", "", ph_final$age)
    ph_final$age <- suppressWarnings(as.numeric(ph_final$age))
  }

  # PMI numérico (aceita "24", "24 hours", etc.)
  if ("pmi" %in% colnames(ph_final)) {
    ph_final$pmi <- gsub("[^0-9.]", "", ph_final$pmi)
    ph_final$pmi <- suppressWarnings(as.numeric(ph_final$pmi))
  }

  # sexo como fator M/F (gender também cai aqui)
  if ("sex" %in% colnames(ph_final)) {
    ph_final$sex <- toupper(trimws(ph_final$sex))
    ph_final$sex[ph_final$sex %in% c("MALE","M","1")]   <- "M"
    ph_final$sex[ph_final$sex %in% c("FEMALE","F","2")] <- "F"
    ph_final$sex <- factor(ph_final$sex)
  }

    # RIN numérico
  if ("rin" %in% colnames(ph_final)) {
    ph_final$rin <- gsub("[^0-9.]", "", ph_final$rin)
    ph_final$rin <- suppressWarnings(as.numeric(ph_final$rin))
  }
  
  # brain pH numérico
  if ("brain_ph" %in% colnames(ph_final)) {
    ph_final$brain_ph <- gsub("[^0-9.]", "", ph_final$brain_ph)
    ph_final$brain_ph <- suppressWarnings(as.numeric(ph_final$brain_ph))
  }
  
  return(ph_final)
}


```


```{R}
# ============================
# GSE101521 (DLPFC BA9)
# Arquivo: GSE101521_totalRNA_counts.csv.gz
# Grupos: CON vs MDD (inclui MDD non-suicide e MDD suicides)
# ============================
message("Processando GSE101521 ...")

# Mudar make counts
cnt_101521 <- read_any(file.path(DATA_DIR, "GSE101521_totalRNA_counts.csv.gz")) %>%
  make_counts_matrix("V1")

save(cnt_101521, file="101521.RData")
# load("101521.RData")

# Metadata via GEOquery
gse_101521 <- getGEO("GSE101521", GSEMatrix = TRUE)
pheno_101521 <- Biobase::pData(gse_101521[[2]]) 

#BA9
pheno_101521_ns <- pheno_101521 %>%
  mutate(group = case_when(
    grepl("\\bCON\\b|control", characteristics_ch1, ignore.case = TRUE) ~ "Control",
    grepl("(MDD)", characteristics_ch1, ignore.case = TRUE) ~ "MDD",
    TRUE ~ NA_character_
  ))

pheno_101521_s <- pheno_101521 %>%
  mutate(group = case_when(
    grepl("\\bCON\\b|control", characteristics_ch1, ignore.case = TRUE) ~ "Control",
    grepl("(MDD-S)", characteristics_ch1, ignore.case = TRUE) ~ "MDD-S",
    grepl("(MDD)", characteristics_ch1, ignore.case = TRUE) ~ "MDD-NS",
    TRUE ~ NA_character_
  ))

pheno_101521_ns <- parse_geo_characteristics(pheno_101521_ns)
pheno_101521_s <- parse_geo_characteristics(pheno_101521_s)

pheno_101521_ns <- pheno_101521_ns %>%
  dplyr::filter(title %in% colnames(cnt_101521))
pheno_101521_s <- pheno_101521_s %>%
  dplyr::filter(title %in% colnames(cnt_101521))

cat(length(pheno_101521_ns$title) == ncol(cnt_101521))
cat(length(pheno_101521_s$title) == ncol(cnt_101521))

covars <- intersect(c("age", "sex", "pmi", "brain_ph", "rin"), colnames(pheno_101521_ns))
covars <- covars[ sapply(pheno_101521_ns[, covars, drop=FALSE], function(x) !all(is.na(x))) ]

res_101521_ns <- find_degs(
  counts        = cnt_101521,
  meta          = pheno_101521_ns %>%
                     dplyr::select(sample_id = title,
                                   condition = group,
                                   dplyr::all_of(covars)),  
  sample_col    = "sample_id",
  condition_col = "condition",
  mdd_values    = c("MDD"),
  control_values= c("Control"),
  tag           = "101521_DLPFC_ns",
  covariates     = covars
)

res_101521_s <- find_degs(
  counts        = cnt_101521,
  meta           = pheno_101521_s %>%
                     dplyr::select(sample_id = title,
                                   condition = group,
                                   dplyr::all_of(covars)),
  sample_col    = "sample_id",
  condition_col = "condition",
  mdd_values    = c("MDD-S"),
  control_values= c("Control"),
  tag           = "101521_DLPFC_s",
  covariates     = covars
)
```

```{R}

# ============================
# GSE80655 (clinically annotated brain RNA-seq)
# Arquivo: GSE80655_GeneExpressionData_Updated_3-26-2018.txt.gz
# ============================
message("Processando GSE80655 ...")
# cnt_80655 <- read_any(file.path(DATA_DIR, "GSE80655_GeneExpressionData_Updated_3-26-2018.txt.gz")) %>%
  # make_counts_matrix("gene_id")

# save(cnt_80655, file="80655.RData")
load("80655.RData")

gse_80655 <- getGEO("GSE80655", GSEMatrix = TRUE)
pheno_80655 <- Biobase::pData(gse_80655[[1]]) 

cat(length(pheno_80655$description) == ncol(cnt_80655))
print(unique(pheno_80655$characteristics_ch1.1))

# Phenotypes
pheno_80655 <- pheno_80655[, !duplicated(colnames(pheno_80655))] %>%
  mutate(
    group = case_when(
      grepl("\\bControl\\b|non-psy|healthy", characteristics_ch1.3, ignore.case = TRUE) ~ "Control",
      grepl("\\bMajor Depression\\b|major\\s*depress", characteristics_ch1.3, ignore.case = TRUE) ~ "MDD",
      grepl("\\bSchizophrenia", characteristics_ch1.3, ignore.case = TRUE) ~ "SCZ",
      grepl("\\bipolar Disorder", characteristics_ch1.3, ignore.case = TRUE) ~ "BPD",
      TRUE ~ NA_character_
    ),
    brain_region = sub("^brain region:\\s*", "", characteristics_ch1.1)  # "AnCg", "nAcc", "DLPFC"
  )

pheno_80655 <- parse_geo_characteristics(pheno_80655)
covars <- intersect(c("age", "sex", "pmi", "brain_ph", "rin"), colnames(pheno_80655))
covars <- covars[sapply(pheno_80655[, covars, drop=FALSE], function(x) !all(is.na(x))) ]

regions <- unique(pheno_80655$brain_region)
res_80655_by_region <- setNames(vector("list", length(regions)), regions)
for (reg in regions) {
  message("Rodando DEGs para região: ", reg)
  
  # Metadados apenas daquela região
  meta_reg <- pheno_80655 %>%
    filter(brain_region == reg)
  
  # Chama sua função find_degs
  res_80655_by_region[[reg]] <- tryCatch(
    find_degs(
      counts         = cnt_80655,
      meta           = meta_reg %>%
                         dplyr::select(sample_id = description,
                                       condition = group,
                                       dplyr::all_of(covars)),
      sample_col    = "sample_id",
      condition_col  = "condition",
      mdd_values     = "MDD",
      control_values = "Control",
      tag            = paste0("80655_", reg),
      covariates     = covars
    ),
    error = function(e) {
      warning("Erro na região ", reg, ": ", conditionMessage(e))
      NULL
    }
  )
}

```
```{R}

# ============================
# GSE214921 (OFC bulk RNA-seq, MDD vs Control)
# Arquivo: GSE214921_human_MDD_filtered_featurecounts_geo.txt.gz
# ============================
message("Processando GSE214921 ...")
# cnt_214921 <- read_any(file.path(DATA_DIR, "GSE214921_human_MDD_filtered_featurecounts_geo.txt.gz")) %>%
  # make_counts_matrix("gene_id")

# save(cnt_214921, file="214921.RData")
load("214921.RData")

gse_214921 <- getGEO("GSE214921", GSEMatrix = TRUE)

# OFC

# Phenotypes
pheno_214921 <- Biobase::pData(gse_214921[[1]])
pheno_214921 <- pheno_214921 %>%
  mutate(group = case_when(
    grepl("MDD", `condition:ch1`, ignore.case = TRUE) ~ "MDD",
    grepl("control", `condition:ch1`, ignore.case = TRUE) ~ "Control",
    TRUE ~ NA_character_
  ))

pheno_214921 <- parse_geo_characteristics(pheno_214921)

cat(length(pheno_214921$title) == ncol(cnt_214921))

covars <- intersect(c("age", "sex", "pmi", "brain_ph", "rin"), colnames(pheno_214921))
covars <- covars[ sapply(pheno_214921[, covars, drop=FALSE], function(x) !all(is.na(x))) ]

res_214921 <- find_degs(
  counts        = cnt_214921, 
  meta          = pheno_214921 %>%
                     dplyr::select(sample_id = title,
                                   condition = group,
                                   dplyr::all_of(covars)),
  sample_col    = "sample_id",
  condition_col = "condition",
  mdd_values    = c("MDD"),
  control_values= c("Control"),
  tag           = "214921_OFC",
  covariates     = covars
)

```


```{R}

# ============================
# GSE248260 (white matter BA47: suicide vs control)
# Arquivo: GSE248260_white_matter_count_matrix.csv.gz
# ATENÇÃO: este estudo é suicídio vs não-suicídio (nem sempre MDD). Rodamos separado.
# ============================
message("Processando GSE248260 ...")

cnt_248260 <- read_any(file.path("GSE248260_white_matter_count_matrix.csv.gz")) %>% make_counts_matrix("V1")

# save(cnt_248260, file="248260.RData")
load("214921.RData")

gse_248260 <- getGEO("GSE248260", GSEMatrix = TRUE)
pheno_248260 <- Biobase::pData(gse_248260[[1]])
  
pheno_248260 <- pheno_248260 %>%
  mutate(group = case_when(
    grepl("MDD", `diagnosis:ch1`, ignore.case = TRUE) ~ "MDD",
    grepl("Normal", `diagnosis:ch1`, ignore.case = TRUE) ~ "Control",
    TRUE ~ NA_character_
  ))

pheno_248260 <- parse_geo_characteristics(pheno_248260)

cat(length(pheno_248260$title) == ncol(cnt_248260))

covars <- intersect(c("age", "sex", "pmi", "brain_ph", "rin"), colnames(pheno_248260))
covars <- covars[ sapply(pheno_248260[, covars, drop=FALSE], function(x) !all(is.na(x))) ]

res_248260 <- find_degs(
  counts        = cnt_248260, 
  meta          = pheno_248260 %>%
                     dplyr::select(sample_id = title,
                                   condition = group,
                                   dplyr::all_of(covars)),
  sample_col    = "sample_id",
  condition_col = "condition",
  mdd_values    = c("MDD"),
  control_values= c("Control"),
  tag           = "248260_VA",
  covariates     = covars
)
```
```{R}
# filtra por p e log
library(readr)
library(dplyr)
# setwd("/home/gbiuser/Documents/vitoria/usp-masters")
res_101521_s <- read_csv("deg_outputs/101521_DLPFC_s_voom_degs.csv", show_col_types=F)
res_101521_ns <- read_csv("deg_outputs/101521_DLPFC_ns_voom_degs.csv", show_col_types=F)

res_80655_nAcc <- read_csv("deg_outputs/80655_nAcc_deseq_degs.csv", show_col_types=F)
res_80655_DLPFC <- read_csv("deg_outputs/80655_DLPFC_deseq_degs.csv", show_col_types=F)
res_80655_AnCg <- read_csv("deg_outputs/80655_AnCg_deseq_degs.csv", show_col_types=F)

res_214921_OFC <- read_csv("deg_outputs/214921_OFC_deseq_degs.csv", show_col_types=F)

res_248260_VA <- read_csv("deg_outputs/248260_VA_deseq_degs.csv", show_col_types=F)


padj_thr <- 0.05
logfc_thr <- 0.6

res_101521_ns_filtered <- res_101521_ns %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

res_101521_s_filtered <- res_101521_s %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

res_80655_nAcc_filtered <- res_80655_nAcc %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

res_80655_DLPFC_filtered <- res_80655_DLPFC %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

res_80655_AnCg_filtered <- res_80655_AnCg %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

res_214921_OFC_filtered <- res_214921_OFC %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

res_248260_VA_filtered <- res_248260_VA %>%
    filter(padj <= padj_thr, abs(log2FoldChange) >= logfc_thr)

degs_214921 <- res_214921_OFC_filtered$gene
degs_248260 <- res_248260_VA_filtered$gene
```


```{r message=FALSE, warning=FALSE}
normalize_ids <- function(x) {
  x <- trimws(x)
  x <- toupper(x)
  sub("\\.\\d+$", "", x)  # drop .1, .2, ...
}
# MAPPING

library(biomaRt)
biomart_mapping <- function(values, 
                            filters_to_try = NULL,
                            mart = NULL,
                            to_attribute = "hgnc_symbol",
                            verbose = FALSE) {
  # Conecta ao Ensembl se não for passado
  if (is.null(mart)) {
    mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
  }

  # Filtros padrão se não forem especificados
  if (is.null(filters_to_try)) {
    filters_to_try <- c(
      "ensembl_gene_id", 
      "ensembl_transcript_id",
      "ensembl_peptide_id",
      "hgnc_symbol", "chembl", "embl", "entrezgene_id",
      "external_gene_name", "hgnc_id", "hpa_id", "hpa_accession", "uniprot_gn_id"
    )
  } else{
    valid_filters <- listFilters(mart)$name
    filters_to_try <- intersect(filters_to_try, valid_filters)
  }

  # Lista para guardar os resultados como data frames
  all_results <- list()

  for (filtro in filters_to_try) {
    if (verbose) cat("Tentando filtro:", filtro, "\n")

    res <- tryCatch({
      getBM(
        attributes = c(filtro, to_attribute, "external_gene_name"),
        filters = filtro,
        values = values,
        mart = mart
      )
    }, error = function(e) {
      if (verbose) message("Erro com filtro: ", filtro, " - ", e$message)
      NULL
    })

    if (!is.null(res) && nrow(res) > 0) {
      # Fallback: if HGNC is empty, use external_gene_name
      res$hgnc_symbol[res$hgnc_symbol == "" | is.na(res$hgnc_symbol)] <- 
        res$external_gene_name[res$hgnc_symbol == "" | is.na(res$hgnc_symbol)]
    
      df <- res[, c(filtro, "hgnc_symbol")]
      colnames(df) <- c("Query", "HGNC_ID")
      all_results[[filtro]] <- df
    }
  }

  # Combina tudo em um único data frame
  if (length(all_results) == 0) {
    return(data.frame(Query = character(0), HGNC_ID = character(0)))
  }

  final_df <- do.call(rbind, all_results)
  return(final_df)
}

#######################################################################
library(data.table)

hgnc_dataset_mapping <- function(targets) {
  library(data.table)

  # Baixar dataset HGNC
  hgnc_url <- "https://storage.googleapis.com/public-download-files/hgnc/tsv/tsv/hgnc_complete_set.txt"
  hgnc_file <- tempfile(fileext = ".tsv")
  download.file(hgnc_url, hgnc_file, quiet = TRUE)

  # Ler com segurança
  hgnc <- fread(hgnc_file, sep = "\t", quote = "", fill = TRUE)

  # Garantir colunas necessárias
  cols <- c("symbol", "alias_symbol", "prev_symbol", "name", "ensembl_gene_id")
  for (col in cols) if (!col %in% names(hgnc)) hgnc[[col]] <- NA_character_

  # Função de expansão
  expand_aliases <- function(symbols, main_symbol) {
    if (is.na(symbols) || symbols == "") return(NULL)
    expanded <- unlist(strsplit(symbols, "\\|"))
    if (length(expanded) == 0) return(NULL)
    data.table(input = toupper(trimws(expanded)), hgnc_symbol = main_symbol)
  }

  safe_rbind <- function(lst) {
    lst <- lst[!sapply(lst, is.null)]
    if (length(lst) == 0) return(data.table(input = character(), hgnc_symbol = character()))
    rbindlist(lst, fill = TRUE)
  }

  # Expandir
  alias_dt  <- safe_rbind(mapply(expand_aliases, hgnc$alias_symbol, hgnc$symbol, SIMPLIFY = FALSE))
  prev_dt   <- safe_rbind(mapply(expand_aliases, hgnc$prev_symbol, hgnc$symbol, SIMPLIFY = FALSE))
  symbol_dt <- data.table(input = toupper(hgnc$symbol), hgnc_symbol = hgnc$symbol)
  name_dt   <- data.table(input = toupper(hgnc$name), hgnc_symbol = hgnc$symbol)

  expanded <- rbindlist(list(symbol_dt, alias_dt, prev_dt, name_dt), fill = TRUE, use.names = TRUE)
  expanded <- unique(expanded[!is.na(input)])

  # Mapeamento
  targets_clean <- toupper(trimws(targets))
  mapped <- expanded[input %in% targets_clean]

  if (nrow(mapped) == 0) {
    warning("Nenhum mapeamento encontrado para os targets fornecidos.")
    return(data.frame(Query = targets, HGNC_ID = NA_character_))
  }

  result <- unique(data.table(Query = mapped$input, HGNC_ID = mapped$hgnc_symbol))
  return(as.data.frame(result))
}

#######################################################################
  
library(hgnc)
library(lubridate)
library(data.table)

hgnc_mapping <- function(values, 
                         from_cols = NULL, 
                         to = "symbol", 
                         hgnc_dataset = NULL, 
                         verbose = FALSE) {
  if (is.null(hgnc_dataset)) {
    if (verbose) cat("Importando base HGNC...\n")
    hgnc_dataset <- import_hgnc_dataset()
  }

  if (is.null(from_cols)) {
    from_cols <- c("hgnc_id", "symbol", "name", "entrez_id", "ensembl_gene_id", "uniprot_ids")
  }
  
  hgnc_long <- setDT(hgnc_dataset)[
    , .(uniprot_id = unlist(strsplit(as.character(uniprot_ids), ",\\s*"))),  # force to character
    by = .(hgnc_id, symbol)
  ]


  # Safe wrapper
  safe_crosswalk <- function(value, from, to, hgnc_dataset) {
    tryCatch({
      crosswalk(value = value, from = from, to = to, hgnc_dataset = hgnc_dataset)
    }, error = function(e) {
      if (verbose) message("Erro na coluna ", from, ": ", e$message)
      NULL
    })
  }

  # Lista para guardar resultados (query, id)
  results_list <- list()

  for (col in from_cols) {
    if (verbose) cat("Tentando coluna:", col, "\n")
    
    if (col == "uniprot_ids") {
      matched <- hgnc_long[uniprot_id %in% values, .(Query = uniprot_id, HGNC_ID = symbol)]
      if (nrow(matched) > 0) results_list[[length(results_list) + 1]] <- matched
    } else {
      for (val in values) {
        res <- tryCatch({
          crosswalk(value = val, from = col, to = to, hgnc_dataset = hgnc_dataset)
        }, error = function(e) {
          if (verbose) message("Erro na coluna ", col, ": ", e$message)
          NULL
        })
        if (!is.null(res) && length(res) > 0) {
          results_list[[length(results_list) + 1]] <- data.frame(Query = val, HGNC_ID = res)
        }
      }
    }
  }

  # Combina tudo e remove duplicatas
  if (length(results_list) == 0) {
    return(data.frame(Query = character(0), HGNC_ID = character(0)))
  }

  final_df <- unique(do.call(rbind, results_list))
  return(final_df)
}

#######################################################################
library(mygene)

mygene_mapping <- function(targets, filters=NULL) {
  
  if(is.null(filters)){
    filters <- "ensembl.gene,emsembl,ensemblgene,uniprot,entrezgene,symbol,name,hgnc,refseq,alias"
  }
  
  res <- suppressWarnings(
    queryMany(targets, scopes = filters,
              fields = "symbol", species = "human", 
              return.as = "records")
  )
  
  if (is.null(res) || length(res) == 0) {
    return(data.frame(Query = character(0), HGNC_ID = character(0), 
                     stringsAsFactors = FALSE))
  }
  
  # Helper for NULL coalescing
  `%||%` <- function(x, y) if (is.null(x)) y else x
  
  # Process the records format
  queries <- sapply(res, function(x) x$query %||% NA)
  symbols <- sapply(res, function(x) x$symbol %||% NA)
  
  df <- data.frame(
    Query = queries,
    HGNC_ID = symbols,
    stringsAsFactors = FALSE
  )
  
  # Remove rows without valid HGNC mapping (including notfound entries)
  df <- df[!is.na(df$HGNC_ID) & df$HGNC_ID != "" & !is.na(df$Query), , drop = FALSE]
  rownames(df) <- NULL
  
  return(df)
}

#######################################################################

map_hgnc_all_methods <- function(targets, verbose = TRUE) {
  
  targets <- normalize_ids(targets)
  
  # Run each mapping function with proper error handling
  results <- list()

  # Biomart
  if (verbose) cat("Running biomart_mapping...\n")
  res_biomart <- tryCatch({
    df <- biomart_mapping(targets)
    df$Source <- "biomart"
    df
  }, error = function(e) {
    warning("biomart_mapping failed: ", e$message)
    NULL
  })
  if (!is.null(res_biomart)) results[["biomart"]] <- res_biomart

  # HGNC downloaded dataset
  if (verbose) cat("\nRunning hgnc_dataset_mapping...\n")
  res_dataset <- tryCatch({
    df <- hgnc_dataset_mapping(targets)
    df$Source <- "hgnc_dataset"
    df
  }, error = function(e) {
    warning("hgnc_dataset_mapping failed: ", e$message)
    NULL
  })
  if (!is.null(res_dataset)) results[["hgnc_dataset"]] <- res_dataset

  # hgnc package
  if (verbose) cat("\nRunning hgnc_package\n")
  res_hgnc <- tryCatch({
    df <- hgnc_mapping(targets, verbose)
    df$Source <- "hgnc_package"
    df
  }, error = function(e) {
    warning("hgnc_package failed: ", e$message)
    NULL
  })
  if (!is.null(res_hgnc)) results[["hgnc_package"]] <- res_hgnc

  # mygene
  if (verbose) cat("\nRunning mygene_mapping...\n")
  res_mygene <- tryCatch({
    df <- mygene_mapping(targets)
    
    # Only add Source if df is not empty
    if (nrow(df) > 0) {
      # Remove rownames before adding column
      rownames(df) <- NULL
      df$Source <- "mygene"
      df
    } else {
      message("No HGNC IDs found for these targets")
      NULL
    }
  }, error = function(e) {
    warning("mygene_mapping failed: ", e$message)
    NULL
  })
  if (!is.null(res_mygene)) results[["mygene"]] <- res_mygene

  if (verbose) cat("\nCombining results...\n")
  
  # Combine all results
  if (length(results) == 0) {
    return(data.frame(Query = character(0), HGNC_ID = character(0), Source = character(0)))
  }

  combined <- do.call(rbind, results)
  return(combined)
}
```

```{R}
# mappings_80655 <- map_hgnc_all_methods(degs_80655)
# all_80655 <- unique(mappings_80655$HGNC_ID)
# all_80655 <- all_80655[!is.na(all_80655)]
# 
# mappings_214951 <- map_hgnc_all_methods(degs_214951)
# all_214951 <- unique(mappings_214951$HGNC_ID)
# all_214951 <- all_214951[!is.na(all_214951)]

mappings_214951 <- map_hgnc_all_methods(degs_214921)
degs_214921_HGNC <- unique(mappings_214951$HGNC_ID)
degs_214921_HGNC <- degs_214921_HGNC[!is.na(degs_214921_HGNC)]
save(degs_214921_HGNC, file="deg_outputs/degs_214921_HGNC.RData")

mappings_248260 <- map_hgnc_all_methods(degs_248260)
results_248260 <- unique(mappings_248260$HGNC_ID)
results_248260 <- results_248260[!is.na(results_248260)]
save(results_248260, file="deg_outputs/results_248260.RData")
```

```{r message=FALSE, warning=FALSE, include=FALSE}
# Pasta com os CSVs das interseções
csv_folder <- "../data/target_prediction/intersections"

# Lista fixa para intersectar
# snrnaseq_intersection <- as.character(snrnaseq_intersection)  # garantir vetor de caracteres

# Lista para guardar os resultados
results_214951 <- list()

# Ler cada arquivo CSV e fazer interseção com snrnaseq_intersection
csv_files <- list.files(csv_folder, pattern = "\\.csv$", full.names = TRUE)

for (file in csv_files) {
  # Read raw lines first
  raw_lines <- readLines(file, warn = FALSE)

  # Skip if all lines are either empty or just '""'
  if (all(trimws(raw_lines) %in% c("", "\"\""))) {
    message(paste("Skipping file with only '\"\"' or blank lines:", file))
    next
  }
  
  # Nome base do arquivo para usar como key
  key <- gsub("^intersection_|\\.csv$", "", basename(file))
  
  # Ler CSV
  # print(file)
  df <- read.csv(file, stringsAsFactors = FALSE)
  # print(file)
  # Garantir vetor
  vec <- as.character(df$target)
  
  # Interseção com snrnaseq_intersection
  inter <- intersect(vec, degs_214921_HGNC)
  
  # Salvar na lista
  results_214951[[key]] <- inter
}

save(results_214951, file="deg_outputs/results_214951.RData")
```

