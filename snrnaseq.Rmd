<!-- # --- -->
title: "Untitled"
author: "vitoria"
date: "2025-04-16"
output: html_document
---

```{r message=FALSE, warning=FALSE, include=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

# Pacotes do CRAN necessários
cran_pkgs <- c(
  "data.table", "dplyr", "future", "future.apply", "ggplot2", "rlang", "irlba", 
  "tidyr", "patchwork", "stringi", "fastmatch", "RcppRoll", "scales", "Rcpp", 
  "devtools",
  "tidyselect", "vctrs", "lifecycle", "dotCall64", "RcppEigen", "png", "reticulate"
)

# Pacotes do Bioconductor necessários
bioc_pkgs <- c(
  "GenomeInfoDb", "GenomicRanges", "IRanges", "Rsamtools", "S4Vectors", 
  "SeuratObject", "Biostrings", "XVector", "Rhtslib", "BiocParallel", 
  "UCSC.utils", "GENIE3", "variancePartition"
)

# Função pra instalar se faltar
install_missing <- function(pkgs, installer) {
  for (pkg in pkgs) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      message(paste("Instalando:", pkg))
      installer(pkg)
    } else {
      message(paste("Já está instalado:", pkg))
    }
  }
}

# Instala os pacotes
install_missing(cran_pkgs, install.packages)
install_missing(bioc_pkgs, BiocManager::install)

if (!requireNamespace("remotes", quietly = TRUE))
    install.packages("remotes")
remotes::install_github("stuart-lab/signac", ref = "develop")

devtools::install_github("immunogenomics/presto")
```

```{r message=FALSE, warning=FALSE}
# Load necessary libraries

# library(GenomeInfoDb)
# library(ggplot2)
# library(patchwork)
library(dplyr)
library(Seurat)
library(Matrix)
# library(variancePartition)
# library(BiocParallel)
```

# Functions

```{r}
#' Builds a Seurat object from snRNA-seq data
#'
#' @param matrix_file String - Path to a .mtx.gz file
#' @param genes_file String - Path to file with gene names
#' @param cells_file String - Path to file with cell names
#' @param project_name String - Name of your project/dataset
#' @param min.cells Integer - Minimum number of cells a gene must be detected in to be retained
#' @param min.features Integer - Minimum number of genes a cell must express to be included
#' @param nfeatures Integer - Number of top variable features to select.
#' @return seurat_obj - SeuratObject for downstream analyses
process_seurat_object <- function(matrix_file, genes_file, cells_file, group_file,
                                  project_name = "SeuratProject",
                                  min_cells = 3, min_features = 100) {
  
  # Load expression matrix
  expr_matrix <- readMM(matrix_file)
  
  # Load gene and cell names
  genes <- read.csv(genes_file, header = TRUE)
  cells <- read.csv(cells_file, header = TRUE)
  
  # Define row and column names
  rownames(expr_matrix) <- make.unique(genes$x)
  colnames(expr_matrix) <- cells$x
  
  # Create object
  seurat_obj <- CreateSeuratObject(counts = expr_matrix, 
                                   project = project_name, 
                                   min.cells = min_cells, 
                                   min.features = min_features)
  
  return(seurat_obj)
}

#' Builds a Seurat object from snRNA-seq data
#'
#' @param seurat_obj SeuratObject
#' @param group_by String - Name of the variable you want to group your data by (condition, treatment, etc)
#' @param ident_1 String - Name of the first group considering the condition above
#' @param ident_2 String - Name of the second group considering the condition above
#' @param method String - Statistical test for differential expression ("wilcox", "t", "bimod", "LR")
#' @param logfc_threshold Integer - Threshold for FoldChange filtering (e.g. > 2)
#' @param pval_adj_threshold Float - Threshold for adjusted p value (e.g. <= 0.01) 
#' @param save Boolean - If you want to save your DEGs as a CSV
#' @param output_path String - Path to save the CSVs
#' @param prefix String - Prefix for the CSV filenames
#' @return list with p-adjusted DEGs and filtered DEGs
run_DE_analysis <- function(seurat_obj,
                            group_by = "condition",
                            ident_1 = "MDD",
                            ident_2 = "Control",
                            method = "wilcox",
                            logfc_threshold = 1,
                            pval_adj_threshold = 0.05,
                            save = FALSE,
                            output_path = "",
                            prefix = "") {
  
  # Find DEGs
  degs <- FindMarkers(seurat_obj,
                      ident.1 = ident_1,
                      ident.2 = ident_2,
                      group.by = group_by,
                      test.use = method)
  
  # Adjust p value
  degs$p_val_adj <- p.adjust(degs$p_val, method = "fdr")
  
  # Filter by p value and FC
  degs_filtered <- degs %>%
    filter(p_val_adj <= pval_adj_threshold, abs(avg_log2FC) >= logfc_threshold)

  # Save if requested
  if (save){
    dir.create(output_path, showWarnings = FALSE, recursive = TRUE)

    write.csv(degs,
              file = file.path(output_path, paste0(prefix, "_results_adj.csv")),
              row.names = TRUE)
  
    write.csv(degs_filtered,
              file = file.path(output_path, paste0(prefix, "_results_filtered.csv")),
              row.names = TRUE)    
  }  

  return(list(degs_all = degs, degs_filtered = degs_filtered))
}

```


```{r}
gse_path <- "data/snrnaseq/GSE213982/"

# Build the Seurat object
GSE213982 <- process_seurat_object(
  matrix_file = paste0(gse_path, "GSE213982_combined_counts_matrix.mtx.gz"),
  genes_file = paste0(gse_path,  "GSE213982_combined_counts_matrix_genes_rows.csv.gz"),
  cells_file = paste0(gse_path, "GSE213982_combined_counts_matrix_cells_columns.csv.gz"),
  project_name = "GSE213982_snRNA"
)

# Gather meta data
cell_info <- do.call(rbind, strsplit(colnames(GSE213982), "\\."))
GSE213982$sample_id <- cell_info[,1]
GSE213982$barcode <- cell_info[,2]
GSE213982$cell_type <- cell_info[,3]

GSE213982$cell_subtype <- cell_info[,4]
GSE213982$cell_subtype <- sub("^([A-Za-z]+)([0-9]+).*", "\\1\\2", GSE213982$cell_subtype)

# Gather groups information
condition_info <- read.csv(paste0(gse_path, "/groups.csv"))
GSE213982$condition <- condition_info$Condition[match(GSE213982$sample_id,
                                                       condition_info$Sample)]
GSE213982$condition[GSE213982$condition == "Case"] <- "MDD"

# Normalization
GSE213982 <- NormalizeData(GSE213982, normalization.method = "LogNormalize")

save(GSE213982, file=paste0(gse_path, "GSE213982_counts.RData"))
```

# Analysis without considering cell types

```{r}
gse_path <- "data/snrnaseq/GSE213982/"
load(paste0(gse_path, "GSE213982_counts.RData"))

degs_GSE213982 <- run_DE_analysis(GSE213982, save = F,
                                  output_path = paste0(gse_path, "degs/"),
                                  prefix = "GSE213982")
GSE213982 <- NULL
gc()
```



## GSE144136

```{r}
gse_path <- "data/snrnaseq/GSE144136/"
GSE144136 <- process_seurat_object(
  matrix_file = paste0(gse_path, "GSE144136_GeneBarcodeMatrix_Annotated.mtx.gz"),
  genes_file = paste0(gse_path, "GSE144136_GeneNames.csv.gz"),
  cells_file = paste0(gse_path, "GSE144136_CellNames.csv.gz"),
  project_name = "GSE144136_snRNA"
)

cell_info <- do.call(rbind, strsplit(colnames(GSE144136), "\\_"))
GSE144136@meta.data$cell_type <- cell_info[,1]
GSE144136@meta.data$cell_subtype <- sub("^([A-Za-z/]+)[_\\./]([0-9]+).*", "\\1\\2",
                                        rownames(GSE144136@meta.data))

GSE144136@meta.data$condition <- ifelse(grepl("Control", rownames(GSE144136@meta.data)), 
                                    "Control", 
                                    ifelse(grepl("Suicide", rownames(GSE144136@meta.data)), 
                                           "MDD", 
                                           NA))

# Make it the same patter as the other dataset
## Cell type
GSE144136@meta.data$cell_type <- dplyr::case_when(
  GSE144136@meta.data$cell_type == "Astros" ~ "Ast",
  GSE144136@meta.data$cell_type == "Inhib" ~ "InN",
  GSE144136@meta.data$cell_type == "Ex" ~ "ExN",
  GSE144136@meta.data$cell_type == "Oligos" ~ "Oli",
  GSE144136@meta.data$cell_type == "OPCs" ~ "OPC",
  grepl("^Micro/Macro", GSE144136@meta.data$cell_type) ~ "Mic",
  grepl("^Endo", GSE144136@meta.data$cell_type) ~ "End",

  TRUE ~ GSE144136@meta.data$cell_type  
)
## Cell subtype
cell_subtype_info <- stringr::str_match(rownames(GSE144136@meta.data), "^([A-Za-z/]+)[_\\./]([0-9]+)")
cell_type <- cell_subtype_info[, 2]
subtype_num <- cell_subtype_info[, 3]
standardized_type <- dplyr::case_when(
  cell_type == "Astros" ~ "Ast",
  cell_type == "Inhib" ~ "InN",
  cell_type == "Ex" ~ "ExN",
  cell_type == "Oligos" ~ "Oli",
  cell_type == "OPCs" ~ "OPC",
  cell_type == "Endo" ~ "End",
  cell_type == "Micro/Macro" ~ "Mic",
  TRUE ~ cell_type
)
GSE144136@meta.data$cell_subtype <- paste0(standardized_type, subtype_num)

GSE144136 <- NormalizeData(GSE144136, normalization.method = "LogNormalize")

save(GSE144136, file=paste0(gse_path, "GSE144136_counts.RData"))
```


```{r}
gse_path <- "data/snrnaseq/GSE144136/"
load(paste0(gse_path, "GSE144136_counts.RData"))

degs_GSE144136 <- run_DE_analysis(GSE144136, save = F,
                                  output_path = paste0(gse_path, "degs/"),
                                  prefix = "/GSE144136")
GSE144136 <- NULL
gc()
```

## Getting the intersection between snRNA-seq and target prediction


```{r}
gse_path <- "data/snrnaseq/GSE144136/"
degs_GSE144136_expr <- read.csv(paste0(gse_path, "degs/GSE144136_results_filtered.csv"))
degs_GSE144136 <- degs_GSE144136_expr$X

gse_path <- "data/snrnaseq/GSE213982/"
degs_GSE213982_expr <- read.csv(paste0(gse_path, "degs/GSE213982_results_filtered.csv"))
degs_GSE213982 <- degs_GSE213982_expr$X

# Load target_intersection 
load(file='data/target_prediction/targets_intersection.RData')

snrnaseq_intersection <- intersect(degs_GSE213982, degs_GSE144136)
notype_intersection  <- intersect(snrnaseq_intersection, targets_intersection)

save(notype_intersection, file = "data/snrnaseq/degs_intersections_notype.RData")
```


# Analysis considering cell types

```{r message=FALSE, warning=FALSE, include=FALSE}
gse_path <- "data/snrnaseq/GSE213982/"
load(paste0(gse_path, "GSE213982_counts.RData"))

GSE213982_celltype <- list()
cell_types <- setdiff(unique(GSE213982@meta.data$cell_type), "Mix")

for (ct in cell_types) {
  seurat_sub <- subset(GSE213982,
                       subset = cell_type == ct)
  
  seurat_sub <- NormalizeData(seurat_sub,
                              normalization.method = "LogNormalize")
  Idents(seurat_sub) <- "condition"

  markers <- FindMarkers(seurat_sub, ident.1 = "MDD",
                         ident.2 = "Control",
                         test.use = "wilcox")
  
  GSE213982_celltype[[ct]] <- markers
  gc()
}

# filter by p and FC
GSE213982_celltype_filtered <- list()
for (ct in cell_types) {
  markers <- GSE213982_celltype[[ct]]
  
  markers_filtered <- markers %>%
    filter(p_val_adj <= 0.05, abs(avg_log2FC) >= 1)

  GSE213982_celltype_filtered[[ct]] <- markers_filtered
}

save(GSE213982_celltype_filtered,
     file=paste0(gse_path, "type_degs/GSE213982_celltype.RData"))
```

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
gse_path <- "data/snrnaseq/GSE144136/"
load(paste0(gse_path, "/GSE144136_counts.RData"))

GSE144136_celltype <- list()
cell_types <- setdiff(unique(GSE144136@meta.data$cell_type), "Mix")

for (ct in cell_types) {
  seurat_sub <- subset(GSE144136, subset = cell_type == ct)
  seurat_sub <- NormalizeData(seurat_sub, normalization.method = "LogNormalize")

  Idents(seurat_sub) <- "condition"

  markers <- FindMarkers(seurat_sub, ident.1 = "MDD", ident.2 = "Control",
                         test.use = "wilcox")

  GSE144136_celltype[[ct]] <- markers
}

# filter by p and FC
GSE144136_celltype_filtered <- list()
for (ct in cell_types) {
  markers <- GSE144136_celltype[[ct]]
  
  markers_filtered <- markers %>%
    filter(p_val_adj < 0.05, abs(avg_log2FC) >= 1)

  GSE144136_celltype_filtered[[ct]] <- markers_filtered
}

save(GSE144136_celltype_filtered,
     file=paste0(gse_path, "type_degs/GSE144136_celltype.RData"))
```

## Getting the intersection between snRNA-seq and target prediction

```{r message=FALSE, warning=FALSE}
# Load target_intersection (303 targets)
load(file='data/target_prediction/targets_intersection.RData')

cell_types <- names(GSE144136_celltype_filtered)

intersection_celltypes <- list()
for (ct in cell_types) {
  intersection_celltypes[[ct]] <- intersect(rownames(GSE144136_celltype_filtered[[ct]]),
                                            rownames(GSE213982_celltype_filtered[[ct]]))
}

type_intersection <- list()
for (ct in cell_types) {
  type_intersection[[ct]] <- intersect(targets_intersection,
                                               intersection_celltypes[[ct]])
}

save(type_intersection, type_intersection_alltargets, file = "data/snrnaseq/degs_intersections_type.RData")
```


# Analysis considering cell subtypes

```{r message=FALSE, warning=FALSE, include=FALSE}
gse_path <- "data/snrnaseq/GSE213982/"
load(paste0(gse_path, "GSE213982_counts.RData"))

GSE213982_markers_subcelltype <- list()
cell_subtypes <- setdiff(unique(GSE213982@meta.data$cell_subtype), "Mix")

for (cst in cell_subtypes) {
  seurat_sub <- subset(GSE213982,
                       subset = cell_subtype == cst)
  
  seurat_sub <- NormalizeData(seurat_sub,
                              normalization.method = "LogNormalize")
  Idents(seurat_sub) <- "condition"

  markers <- FindMarkers(seurat_sub, ident.1 = "MDD",
                         ident.2 = "Control",
                         test.use = "wilcox")
  
  GSE213982_markers_subcelltype[[cst]] <- markers
  gc()
}

# filter by p and FC
GSE213982_cellsubtype_filt <- list()
for (cst in names(GSE213982_markers_subcelltype)) {
  markers <- GSE213982_markers_subcelltype[[cst]]
  
  markers_filtered <- markers %>%
    filter(p_val_adj < 0.05, abs(avg_log2FC) >= 1)

  GSE213982_cellsubtype_filt[[cst]] <- markers_filtered
}

save(GSE213982_cellsubtype_filt,
     file=paste0(gse_path, "subtype_degs/GSE213982_subtype.RData"))
```

```{r message=FALSE, warning=FALSE, include=FALSE}
gse_path <- "data/snrnaseq/GSE144136/"
load(paste0(gse_path, "GSE144136_counts.RData"))

GSE144136_markers_subcelltype <- list()
cell_subtypes <- setdiff(unique(GSE144136@meta.data$cell_subtype), "Mix")

for (cst in cell_subtypes) {
  seurat_sub <- subset(GSE144136,
                       subset = cell_subtype == cst)
  
  if (!all(c("MDD", "Control") %in% unique(seurat_sub$condition))) {
    message("Skipping ", cst, " due to missing $condition(s)")
    next
  }
  
  seurat_sub <- NormalizeData(seurat_sub,
                              normalization.method = "LogNormalize")
  seurat_sub <- SetIdent(seurat_sub, value = "condition")

  markers <- FindMarkers(seurat_sub, ident.1 = "MDD",
                         ident.2 = "Control",
                         test.use = "wilcox")
  
  GSE144136_markers_subcelltype[[cst]] <- markers
  gc()
}

# filter by p and FC
GSE144136_cellsubtype_filt <- list()
for (cst in names(GSE144136_markers_subcelltype)) {
  markers <- GSE144136_markers_subcelltype[[cst]]
  
  markers_filtered <- markers %>%
    filter(p_val_adj < 0.05, abs(avg_log2FC) >= 1)

  GSE144136_cellsubtype_filt[[cst]] <- markers_filtered
}

save(GSE144136_cellsubtype_filt,
     file=paste0(gse_path, "subtype_degs/GSE144136_subtype.RData"))
```

## Getting the intersection between snRNA-seq and target prediction

```{r message=FALSE, warning=FALSE}
# Load target_intersection 
load(file='data/target_prediction/targets_intersection.RData')

cell_subtypes <- union(names(GSE144136_cellsubtype_filt), names(GSE213982_cellsubtype_filt))

intersection_cellsubtypes <- list()
for (cst in cell_subtypes) {
  if (cst %in% names(GSE213982_cellsubtype_filt) &
      cst %in% names(GSE144136_cellsubtype_filt)) {
    intersection_cellsubtypes[[cst]] <- intersect(
      rownames(GSE144136_cellsubtype_filt[[cst]]),
      rownames(GSE213982_cellsubtype_filt[[cst]])
    )
  }
}

subtype_intersection <- list()
for (cst in cell_subtypes) {
  subtype_intersection[[cst]] <- intersect(targets_intersection,
                                               intersection_cellsubtypes[[cst]])
}

save(subtype_intersection, file = "data/snrnaseq/degs_intersections_subtype.RData")
```

# Variance partitioning

```{r message=FALSE, warning=FALSE}
extract_top_variable_genes <- function(
  gse_path,
  use_variable_features = TRUE,
  nfeatures = 15000,
  chunk_size = 1000,
  n_cores = 4
) {
  # Derivar nome base do diretório
  base_name <- basename(normalizePath(gse_path))
  counts_file <- file.path(gse_path, paste0(base_name, "_counts.RData"))
  
  # Criar ambiente temporário e carregar objeto
  tmp_env <- new.env()
  load(counts_file, envir = tmp_env)
  
  # Pega o primeiro objeto do .RData
  seurat_object <- tmp_env[[ls(tmp_env)[1]]]
  rm(tmp_env)
  gc()
  
  seurat_matrix <- GetAssayData(seurat_object, assay = "RNA", slot = "data")

  # Seleciona genes variáveis, se indicado
  if (use_variable_features) {
    seurat_object <- FindVariableFeatures(seurat_object,
                                          selection.method = "vst",
                                          nfeatures = nfeatures)
    variable_genes <- VariableFeatures(seurat_object)

    seurat_matrix <- seurat_matrix[variable_genes, ]
  }

  # Preparar metadados
  meta_data <- seurat_object@meta.data
  # Se orig.ident não tiver variação, usar sample_id (se disponível)
  if (length(unique(meta_data$orig.ident)) <= 1 && "sample_id" %in% colnames(meta_data)) {
    message("orig.ident has only one level — replacing with sample_id.")
    meta_data$orig.ident <- meta_data$sample_id
  }
  meta_data$condition <- as.numeric(factor(meta_data$condition))
  meta_data$cell_type <- as.numeric(factor(meta_data$cell_type))

  seurat_object <- NULL
  gc()

  # Fórmula para particionar variância
  form <- ~ (1 | orig.ident) + condition + cell_type

  # Parâmetro de paralelismo
  param <- SnowParam(workers = n_cores, type = "SOCK", progressbar = FALSE)

  # Rodar por chunks
  gene_names <- rownames(seurat_matrix)
  n_genes <- length(gene_names)
  # varPart_list <- list()
  
  dir.create(file.path(gse_path, "variance"), showWarnings = FALSE, recursive = TRUE)


  for (i in seq(1, n_genes, by = chunk_size)) {
    cat("Processing genes", i, "to", min(i + chunk_size - 1, n_genes), "\n")
    gene_subset <- gene_names[i:min(i + chunk_size - 1, n_genes)]
    matrix_chunk <- seurat_matrix[gene_subset, ]

    varPart_chunk <- fitExtractVarPartModel(matrix_chunk, form, meta_data, BPPARAM = param)
    # varPart_list[[length(varPart_list) + 1]] <- varPart_chunk
    save(varPart_chunk, file=paste0(gse_path, "/variance/chunk_", i, "_", i+ chunk_size -1, ".RData"))

    rm(matrix_chunk)
    gc()
  }
  message("Todos os chunks salvos em: ", file.path(gse_path, "variance"))

}

combine_varPart_results <- function(gse_path) {
  variance_dir <- file.path(gse_path, "variance")
  files <- list.files(variance_dir, pattern = "^chunk.*\\.RData$", full.names = TRUE)
  
  # print(files)

  varPart_list <- lapply(files, function(f) {
    load(f)
    return(varPart_chunk)
  })

  varPart_combined <- do.call(rbind, varPart_list)
  varPart_combined$gene <- rownames(varPart_combined)

  return(varPart_combined)
}
```

```{r message=FALSE, warning=FALSE}
gse_path <- "data/snrnaseq/GSE213982/"
extract_top_variable_genes(gse_path,use_variable_features = F,
                           chunk_size = 1000, n_cores = 4)
combined_GSE213982 <- combine_varPart_results(gse_path)
threshold <- quantile(combined_GSE213982$condition, 0.99)
top_genes_GSE213982 <- subset(combined_GSE213982, condition >= threshold)
save(combined_GSE213982, top_genes_GSE213982, file = paste0(gse_path, "variance/variance_GSE213982.RData"))

gse_path <- "data/snrnaseq/GSE144136/"
extract_top_variable_genes(gse_path, use_variable_features = F,
                           chunk_size = 1000, n_cores = 4)
combined_GSE144136 <- combine_varPart_results(gse_path)
threshold <- quantile(combined_GSE144136$condition, 0.95)
top_genes_GSE144136 <- subset(combined_GSE144136, condition >= threshold)
save(combined_GSE144136, top_genes_GSE144136, file = paste0(gse_path, "variance/variance_GSE144136.RData"))

load("data/target_prediction/targets_intersection.RData")

common_degs <- intersect(top_genes_GSE213982$gene, top_genes_GSE144136$gene)
variance_intersection <- intersect(common_degs, targets_intersection)

save(variance_intersection, file = "data/snrnaseq/variance_intersection.RData")
```


# Getting the predicted metabolites/ligands for the intersection genes

```{r}
source("get_metabolites.R")  

load("data/all_analyses_comparison.RData")
rnaseq_genes <- gene_analyses_df[!gene_analyses_df$analyses %in% c("twas", "variance"), ]$gene

targets_to_metabolites <- get_metabolites(rnaseq_genes)

for (target in names(targets_to_metabolites)){
  mets <- targets_to_metabolites[[target]]
  new_mets <- c()
  for (met in mets){
    name <- df3[df3$CID == met,]$name
    new_mets <- c(new_mets, name)
  }
  targets_to_metabolites[[target]] <- new_mets
}

metabolites_to_targets <- list()

for (gene in names(targets_to_metabolites)) {
  print(gene)
  for (metabolite in targets_to_metabolites[[gene]]) {
    print(metabolite)
    metabolites_to_targets[[metabolite]] <- c(metabolites_to_targets[[metabolite]], gene)
  }
}
metabolites_to_targets <- lapply(metabolites_to_targets, unique)

save(targets_to_metabolites, metabolites_to_targets, file="targets_metabolites.RData")
```

# Regulatory network analysis

```{R}
get_expr_matrix <- function(seurat_obj, genes) {
  # Subset dos genes
  mat_sub <- subset(seurat_obj, features = genes)
  
  seurat_obj <- NULL
  gc()
  
  # Obter matriz de expressão (data slot)
  expr_matrix <- GetAssayData(mat_sub, assay = "RNA", layer = "data")
  
  # Transpor e converter para matriz
  expr_matrix <- t(as.matrix(expr_matrix))
  
  return(expr_matrix)
}
```

```{R}
library(ppcor)
library(igraph)
library(ggraph)
library(ggplot2)
library(patchwork)  

ppcor_network_analysis <- function(expr_matrix, query_genes){
  resultados <- data.frame(
    Gene1 = character(),
    Gene2 = character(),
    Estimate = numeric(),
    P.value = numeric(),
    stringsAsFactors = FALSE
  )
  
  for (gene in query_genes) {
    other_genes <- setdiff(query_genes, gene)
    for (target_gene in other_genes) {
      control_genes <- setdiff(other_genes, query_genes)
      
      pcor_result <- pcor.test(
        expr_matrix[, gene],
        expr_matrix[, target_gene],
        expr_matrix[, control_genes]
      )
      
      resultados <- rbind(resultados, data.frame(
        Gene1 = gene,
        Gene2 = target_gene,
        Estimate = pcor_result$estimate,
        P.value = pcor_result$p.value
      ))
    }
  }
  
  # Filtrar por p-valor significativo
  sig_results <- subset(resultados, abs(Estimate) > 0.05 & P.value < 0.001)
  
  # Criar grafo
  g <- graph_from_data_frame(sig_results[, c("Gene1", "Gene2")], directed = FALSE)
  E(g)$weight <- abs(sig_results$Estimate)
  
  # Calcular métricas
  Degree <- degree(g)
  bet <- betweenness(g, weights = abs(E(g)$weight))
  close <- closeness(g, weights = abs(E(g)$weight))
  eigen <- eigen_centrality(g, weights = abs(E(g)$weight))$vector
  
  safe_norm <- function(x) {
    if (max(x) == min(x)) {
      return(rep(0.5, length(x))) 
    } else {
      return((x - min(x)) / (max(x) - min(x)))
    }
  }
  
  # Criar data.frame dos nós com métricas e cores normalizadas
  norm <- function(x) (x - min(x)) / (max(x) - min(x))
  
  nodes <- data.frame(
    name = V(g)$name,
    degree = Degree,
    bet = bet,
    close = close,
    eigen = eigen
  )
  
  # Normalizar métricas para escala de cor
  nodes$cor_degree <- safe_norm(nodes$degree)
  nodes$cor_bet <- safe_norm(nodes$bet)
  nodes$cor_close <- safe_norm(nodes$close)
  nodes$cor_eigen <- safe_norm(nodes$eigen)

  # Layout fixo para todos os plots
  layout <- create_layout(g, layout = "kk")
  
  # Função para gerar plots
  plot_grafo <- function(metric_col, title) {
    ggraph(layout) +
        geom_edge_link(aes(),  width = 0.8,
                       alpha = 0.3, color = "gray80") +
        geom_node_point(aes(fill = metric_col),
                        size = 6, shape = 21, color = "gray", stroke = 1) +
        geom_text_repel(data = layout,
                        aes(x = x, y = y, label = name),
                        size = 4,
                        force = 2,              
                        max.overlaps = Inf,
                        box.padding = 0.5,
                        point.padding = 0.3,
                        segment.color = "grey50") +
        scale_fill_gradient(low = "white", high = "darkred") +
        labs(title = title, color = "") +
        theme_void() +
        theme(
          plot.title = element_text(hjust = 0.5),
          legend.position = "bottom",
          plot.margin = margin(5, 5, 5, 5)
        )
  }
  
  # Gerar os quatro plots
  p1 <- plot_grafo(nodes$cor_bet, "Betweenness")
  p2 <- plot_grafo(nodes$cor_eigen, "Eigenvector")
  p3 <- plot_grafo(nodes$cor_close, "Closeness")
  p4 <- plot_grafo(nodes$cor_degree, "Degree")

  p_final <- (p1 | p2) / (p3 | p4) + plot_layout(guides = "collect") & theme(legend.position = "bottom")
  
  return(list(sig_results, p_final))

}
```

```{R}
final_genes <- c("F3", "S1PR1", "EDNRB", "TRIL", "NR4A1", "FOS")

gse_path <- "data/snrnaseq/GSE213982/"
load(paste0(gse_path, "GSE213982_counts.RData"))
expr_matrix_GSE213982 <- get_expr_matrix(GSE213982, final_genes)

p_final_GSE213982 <- ppcor_network_analysis(expr_matrix_GSE213982, final_genes)

gse_path <- "data/snrnaseq/GSE144136/"
load(paste0(gse_path, "GSE144136_counts.RData"))
expr_matrix_GSE144136 <- get_expr_matrix(GSE144136, final_genes)

p_final_GSE144136 <- ppcor_network_analysis(expr_matrix_GSE213982, final_genes)
```

```{r}
gse_path <- "data/snrnaseq/GSE144136/"
load(paste0(gse_path, "GSE144136_counts.RData"))
genes_f3 <- related_genes_f3$intersect
expr_matrix_GSE144136 <- get_expr_matrix(GSE144136, genes_f3)
GSE144136 <- NULL
gc()
GSE144136_f3_results <- ppcor_network_analysis(expr_matrix_GSE144136, genes_f3)
p_GSE144136_f3 <- GSE144136_f3_results[[2]]
ggsave(paste0(gse_path, "f3_network_GSE144136.jpg"), p_GSE144136_f3)

gse_path <- "data/snrnaseq/GSE213982/"
load(paste0(gse_path, "GSE213982_counts.RData"))
genes_f3 <- related_genes_f3$intersect
expr_matrix_GSE213982 <- get_expr_matrix(GSE213982, genes_f3)
GSE213982 <- NULL
gc()
GSE213982_f3_results <- ppcor_network_analysis(expr_matrix_GSE213982, genes_f3)
p_GSE213982_f3 <- GSE213982_f3_results[[2]]
ggsave(paste0(gse_path, "f3_network_GSE213982.jpg"), p_GSE213982_f3)
```

```{r}
# pegar gse 213, pegar só Ast. Pegar expr
gse_path <- "data/snrnaseq/GSE213982/"
load(paste0(gse_path, "GSE213982_counts.RData"))
seurat_Ast <- subset(GSE213982, subset = cell_type == "Ast")
seurat_Ast <- NormalizeData(seurat_Ast,
                              normalization.method = "LogNormalize")
genes_fos <- related_genes_fos$GSE213982_celltype

expr_matrix_GSE213982 <- get_expr_matrix(seurat_Ast, genes_fos)
GSE213982 <- NULL
gc()
p_GSE213982_fos <- ppcor_network_analysis(expr_matrix_GSE213982, genes_fos)

ggsave(paste0(gse_path, "fos_network_GSE144136.jpg"), p_GSE213982_fos)
```

# Prepare FC data for GSEA

```{r}
library(Seurat)
gse_path <- "data/snrnaseq/GSE213982/"
load(paste0(gse_path, "GSE213982_counts.RData"))

gse_path <- "data/snrnaseq/GSE144136/"
load(paste0(gse_path, "GSE144136_counts.RData"))

obj_list <- list(GSE213982 = GSE213982, GSE144136 = GSE144136)

obj_list_processed <- lapply(obj_list, function(obj) {
  obj <- FindVariableFeatures(obj, nfeatures = 2000, assay = "RNA", slot = "data")
  obj <- ScaleData(obj, features = VariableFeatures(obj))
  obj <- RunPCA(obj, features = VariableFeatures(obj))
  return(obj)
})

# n variables = 2000
features <- SelectIntegrationFeatures(object.list = obj_list_processed, nfeatures = 2000)

integrate_in_chunks_with_global_anchors <- function(obj_list_processed, features, chunk_size,
                                                    out_dir = "chunks_integrados", seed = 42) {
  if (!dir.exists(out_dir)) dir.create(out_dir)

  set.seed(seed)

  message("=== Passo 1: Encontrando âncoras globais ===")
  anchors <- FindIntegrationAnchors(
    object.list = obj_list_processed,
    anchor.features = features,
    reduction = "rpca"
  )

  # Todas as células (union, já que nomes diferem)
  all_cells <- Reduce(union, lapply(obj_list_processed, colnames))

  # Dividir em chunks
  chunks <- split(all_cells, ceiling(seq_along(all_cells) / chunk_size))

  message("=== Passo 2: Integrando em ", length(chunks), " chunks ===")
  for (i in seq_along(chunks)) {
    message("Integrando chunk ", i, " de ", length(chunks))

    # Filtrar cada objeto para as células do chunk (pode ficar vazio em alguns)
    chunk_objs <- lapply(obj_list_processed, function(obj) {
      keep_cells <- intersect(colnames(obj), chunks[[i]])
      if (length(keep_cells) > 0) subset(obj, cells = keep_cells) else NULL
    })
    chunk_objs <- Filter(Negate(is.null), chunk_objs)

    if (length(chunk_objs) < 2) {
      message("Chunk ", i, " ignorado (menos de 2 objetos com células).")
      next
    }

    # Integrar usando âncoras globais
    integrated_chunk <- IntegrateData(anchorset = anchors, new.data = chunk_objs)

    # Salvar
    saveRDS(integrated_chunk, file = file.path(out_dir, sprintf("chunk_%03d.rds", i)))

    rm(integrated_chunk, chunk_objs)
    gc()
  }

  invisible(TRUE)
}

merge_chunks_to_dataset <- function(chunks_dir, block_size = 20, final_outfile = "merged_dataset.rds") {
  chunk_files <- list.files(chunks_dir, pattern = "\\.rds$", full.names = TRUE)
  
  if (length(chunk_files) == 0) {
    stop("Nenhum arquivo .rds encontrado no diretório.")
  }
  
  message("Total de chunks encontrados: ", length(chunk_files))
  
  # Criar pasta para blocos intermediários
  blocks_dir <- file.path(chunks_dir, "blocks")
  if (!dir.exists(blocks_dir)) dir.create(blocks_dir)
  
  # block_idx <- 1
  # for (i in seq(1, length(chunk_files), by = block_size)) {
  #   message("fazendo merge do bloco ", block_idx)
  #   block_files <- chunk_files[i:min(i + block_size - 1, length(chunk_files))]
  #   
  #   objs <- lapply(block_files, readRDS)
  #   merged_block <- Reduce(function(x, y) merge(x, y), objs)
  #   
  #   saveRDS(merged_block, file.path(blocks_dir, paste0("block_", block_idx, ".rds")))
  #   rm(objs, merged_block)
  #   gc()
  #   
  #   block_idx <- block_idx + 1
  # }
  
  # Merge final dos blocos salvos
  message("merge final dos blocos...")
  block_files <- list.files(blocks_dir, pattern = "\\.rds$", full.names = TRUE)
  final_objs <- lapply(block_files, readRDS)
  final_merged <- Reduce(function(x, y) merge(x, y), final_objs)
  
  saveRDS(final_merged, final_outfile)
  message("merge final salvo em: ", final_outfile)
  
  invisible(final_merged)
}

merge_chunks_incremental <- function(blocks_dir, final_outfile = "merged_dataset.rds") {
  block_files <- list.files(blocks_dir, pattern = "\\.rds$", full.names = TRUE)
  
  if (length(block_files) == 0) {
    stop("Nenhum arquivo de bloco encontrado.")
  }
  
  message("Total de blocos encontrados: ", length(block_files))
  
  # Carrega o primeiro bloco como base
  message("Carregando bloco 1 como base...")
  merged_obj <- readRDS(block_files[1])
  
  # Faz merge um a um para economizar RAM
  if (length(block_files) > 1) {
    for (i in 2:length(block_files)) {
      message("merge com bloco ", i, " de ", length(block_files))
      
      obj_next <- readRDS(block_files[i])
      merged_obj <- merge(merged_obj, obj_next)
      
      rm(obj_next)
      gc()
    }
  }
  
  saveRDS(merged_obj, final_outfile)
  message("mrge final salvo em: ", final_outfile)
  
  invisible(merged_obj)
}

gse_path <- "data/snrnaseq/merged/integration"

# Rodar integração em chunks e salvar
integrate_in_chunks(obj_list_processed, features, chunk_size = 300, out_dir = gse_path)

merged_obj <- merge_chunks_to_dataset(gse_path)

save(merged_obj, file=paste0(gse_path, "merged_counts.RData"))
```

```{r}
gse_path <- "data/snrnaseq/merged/"
load(paste0(gse_path, "merged_counts.RData"))

degs_merged <- run_DE_analysis(merged, save = TRUE,
                                output_path=paste0(gse_path, "degs/"),
                                prefix="/merged")

degs_merged <- degs_merged@degs_filtered
# Load target_intersection 
load(file='data/target_prediction/targets_intersection.RData')

merged_notype_intersection  <- intersect(degs_merged, targets_intersection)

save(notype_intersection, file = "data/snrnaseq/degs_intersections_merged_notype.RData")
```

```{r}
gse_path <- "data/snrnaseq/GSE144136/"
degs_GSE144136_expr <- read.csv(paste0(gse_path, "degs/GSE144136_results_filtered.csv"))
degs_GSE144136 <- degs_GSE144136_expr$X

# gse_path <- "data/snrnaseq/GSE213982/"
# degs_GSE213982_expr <- read.csv(paste0(gse_path, "degs/GSE213982_results_filtered.csv"))
# degs_GSE213982 <- degs_GSE213982_expr$X

mapped_ids <- convert_ids(degs_GSE144136_expr$X)
valid_genes <- names(mapped_ids)[!is.na(mapped_ids)]
gene_fc <- degs_GSE144136_expr$avg_log2FC[degs_GSE144136_expr$X %in% valid_genes]
names(gene_fc) <- unlist(mapped_ids[valid_genes])
gene_fc <- sort(gene_fc, decreasing = TRUE)


gsea_reactome <- gsePathway(geneList = gene_fc,
                              organism = "human",   # or "mouse"
                              minGSSize    = 5,
                              maxGSSize    = 1000,
                              pvalueCutoff = 0.05,
                              verbose = FALSE
                            )
edox <- setReadable(gsea_reactome, 'org.Hs.eg.db', 'ENTREZID')
p_gsea_reactome <- cnetplot(edox, categorySize="geneNum", foldChange=gene_fc)

gsea_bp <- gseGO(geneList          = gene_fc,
                      OrgDb        = org.Hs.eg.db,
                      ont          = "BP",
                      minGSSize    = 5,
                      maxGSSize    = 1000,
                      pvalueCutoff = 0.05,
                      verbose      = FALSE)

edox <- setReadable(gsea_bp, 'org.Hs.eg.db', 'ENTREZID')
p_gsea_bp <- cnetplot(edox, categorySize="geneNum", foldChange=gene_fc)
```